const Lead = require('../models/Lead');
const crypto = require('crypto');
const sessionSecurity = require('../utils/sessionSecurity');
class BrowserSessionService {
  constructor() {
    this.sessionTimeout = 30 * 24 * 60 * 60 * 1000;
  }
  /**
   * @deprecated The session capture logic is now handled by creating a persistent session directly on Browserless.io.
   * This function is kept for legacy reference but should not be used.
   */
  async captureSession(page, options = {}) {
    console.warn('DEPRECATED: captureSession is no longer in use. Sessions are created directly on the remote browser service.');
    // Return a placeholder structure
    return {
      sessionId: `deprecated_${this.generateSessionId()}`,
      metadata: {
        notes: 'This is a deprecated session format.'
      }
    };
  }
  async storeSession(leadId, sessionData, orderId = null, assignedBy = null) {
    try {
      console.log(`üíæ Storing Browserless.io session for lead: ${leadId}`);
      console.log(`üîë Received Session ID: ${sessionData.sessionId}`);
      
      const validationResult = this.validateSession(sessionData);
      if (!validationResult.isValid) {
        throw new Error(`Invalid session data: ${validationResult.errors.join(', ')}`);
      }

      const lead = await Lead.findById(leadId);
      if (!lead) {
        throw new Error(`Lead not found: ${leadId}`);
      }

      // The session data from the script is already in the desired format.
      // We just need to ensure system-managed fields are set correctly.
      const sessionToStore = {
        sessionId: sessionData.sessionId, // Use the ID generated by the script
        cookies: [], // No longer stored
        localStorage: {}, // No longer stored
        sessionStorage: {}, // No longer stored
        userAgent: sessionData.userAgent || 'Browserless-Managed',
        viewport: sessionData.viewport || { width: 1920, height: 1080 },
        createdAt: new Date(),
        lastAccessedAt: new Date(),
        isActive: true,
        metadata: {
          ...sessionData.metadata,
          orderId: orderId,
          assignedBy: assignedBy
        }
      };

      // Encryption is still a good practice for metadata, even if it's smaller.
      const encryptedSessionData = sessionSecurity.encryptSessionData(sessionToStore);
      
      const updatedLead = await lead.storeBrowserSession(encryptedSessionData, orderId, assignedBy);
      
      sessionSecurity.logSessionAccess({
        sessionId: sessionData.sessionId,
        leadId: leadId,
        userId: assignedBy,
        userRole: 'system',
        action: 'store',
        success: true,
        metadata: {
          orderId: orderId,
          domain: sessionData.metadata?.domain,
          injectionType: sessionData.metadata?.injectionType
        }
      });

      console.log(`‚úÖ Browserless session stored and encrypted successfully for lead: ${leadId}`);
      return updatedLead;
    } catch (error) {
      console.error('‚ùå Error storing session:', error);
      throw new Error(`Failed to store session: ${error.message}`);
    }
  }
  /**
   * @deprecated Session restoration is now handled by connecting to a persistent session on Browserless.io using its session ID.
   * This function is kept for legacy reference but should not be used.
   */
  async restoreSession(page, sessionData, options = {}) {
    console.warn('DEPRECATED: restoreSession is no longer in use. Connect to the session via its ID on Browserless.io.');
    return false;
  }
  generateSessionId() {
    const timestamp = Date.now();
    const randomBytes = crypto.randomBytes(16).toString('hex');
    return `session_${timestamp}_${randomBytes}`;
  }
  validateSession(sessionData) {
    const errors = [];
    try {
      if (!sessionData) {
        errors.push('Session data is null or undefined');
        return { isValid: false, errors };
      }
      if (!sessionData.sessionId || typeof sessionData.sessionId !== 'string' || sessionData.sessionId.length < 10) {
        errors.push('A valid Session ID is required');
      }
      if (!sessionData.metadata || typeof sessionData.metadata !== 'object') {
        errors.push('Metadata object is required');
      }
      
      // We no longer validate cookies, storage, etc.
      // The presence of a valid sessionId is the most important check.

    } catch (error) {
      errors.push(`Validation error: ${error.message}`);
    }
    return {
      isValid: errors.length === 0,
      errors
    };
  }
  async updateSessionAccess(sessionId) {
    try {
      const lead = await Lead.findOne({
        $or: [
          { 'browserSession.sessionId': sessionId },
          { 'sessionHistory.sessionId': sessionId }
        ]
      });
      if (!lead) {
        throw new Error(`No lead found with session ID: ${sessionId}`);
      }
      await lead.updateSessionAccess(sessionId);
      console.log(`üïí Updated last access time for session: ${sessionId}`);
      return lead;
    } catch (error) {
      console.error('‚ùå Error updating session access:', error);
      throw new Error(`Failed to update session access: ${error.message}`);
    }
  }
  async getSessionByLeadId(leadId, sessionId = null) {
    try {
      const lead = await Lead.findById(leadId);
      if (!lead) {
        throw new Error(`Lead not found: ${leadId}`);
      }
      if (sessionId) {
        return lead.getSessionById(sessionId);
      } else {
        return lead.getCurrentBrowserSession();
      }
    } catch (error) {
      console.error('‚ùå Error getting session:', error);
      throw new Error(`Failed to get session: ${error.message}`);
    }
  }
  async hasActiveSession(leadId) {
    try {
      const lead = await Lead.findById(leadId);
      if (!lead) {
        return false;
      }
      return lead.hasActiveBrowserSession();
    } catch (error) {
      console.error('‚ùå Error checking active session:', error);
      return false;
    }
  }
  async deactivateSession(leadId) {
    try {
      const lead = await Lead.findById(leadId);
      if (!lead) {
        throw new Error(`Lead not found: ${leadId}`);
      }
      await lead.deactivateCurrentSession();
      console.log(`üîÑ Deactivated current session for lead: ${leadId}`);
      return lead;
    } catch (error) {
      console.error('‚ùå Error deactivating session:', error);
      throw new Error(`Failed to deactivate session: ${error.message}`);
    }
  }
  async cleanupExpiredSessions(daysOld = 30) {
    try {
      console.log(`üßπ Starting cleanup of sessions older than ${daysOld} days...`);
      const leads = await Lead.find({
        $or: [
          { 'browserSession.createdAt': { $exists: true } },
          { 'sessionHistory.0': { $exists: true } }
        ]
      });
      let cleanedLeads = 0;
      let totalSessionsRemoved = 0;
      for (const lead of leads) {
        const initialSessionCount = lead.sessionHistory.length + (lead.browserSession ? 1 : 0);
        await lead.clearExpiredSessions(daysOld);
        const finalSessionCount = lead.sessionHistory.length + (lead.browserSession ? 1 : 0);
        const sessionsRemoved = initialSessionCount - finalSessionCount;
        if (sessionsRemoved > 0) {
          cleanedLeads++;
          totalSessionsRemoved += sessionsRemoved;
        }
      }
      const stats = {
        leadsProcessed: leads.length,
        leadsCleaned: cleanedLeads,
        totalSessionsRemoved,
        daysThreshold: daysOld
      };
      console.log('‚úÖ Session cleanup completed:', stats);
      return stats;
    } catch (error) {
      console.error('‚ùå Error during session cleanup:', error);
      throw new Error(`Failed to cleanup sessions: ${error.message}`);
    }
  }
  async getSessionStatistics() {
    try {
      const stats = await Lead.aggregate([
        {
          $match: {
            $or: [
              { 'browserSession': { $exists: true } },
              { 'sessionHistory.0': { $exists: true } }
            ]
          }
        },
        {
          $project: {
            hasActiveSession: { $ifNull: ['$browserSession.isActive', false] },
            totalSessions: {
              $add: [
                { $cond: [{ $ifNull: ['$browserSession', false] }, 1, 0] },
                { $size: { $ifNull: ['$sessionHistory', []] } }
              ]
            },
            sessionHistoryCount: { $size: { $ifNull: ['$sessionHistory', []] } },
            lastSessionDate: {
              $max: [
                '$browserSession.createdAt',
                { $max: '$sessionHistory.createdAt' }
              ]
            }
          }
        },
        {
          $group: {
            _id: null,
            totalLeadsWithSessions: { $sum: 1 },
            leadsWithActiveSessions: { $sum: { $cond: ['$hasActiveSession', 1, 0] } },
            totalSessions: { $sum: '$totalSessions' },
            averageSessionsPerLead: { $avg: '$totalSessions' },
            mostRecentSession: { $max: '$lastSessionDate' }
          }
        }
      ]);
      return stats[0] || {
        totalLeadsWithSessions: 0,
        leadsWithActiveSessions: 0,
        totalSessions: 0,
        averageSessionsPerLead: 0,
        mostRecentSession: null
      };
    } catch (error) {
      console.error('‚ùå Error getting session statistics:', error);
      throw new Error(`Failed to get session statistics: ${error.message}`);
    }
  }
}
module.exports = new BrowserSessionService();